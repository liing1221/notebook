{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# cv2库介绍与使用\n",
    "\n",
    "\n",
    "\n",
    "## 一、关于OpenCV\n",
    "### 1.1、介绍\n",
    "　　OpenCV是一个基于BSD许可（开源）发行的跨平台计算机视觉库，可以运行在Linux、Windows、Android和Mac OS操作系统上。它轻量级而且高效——由一系列 C 函数和少量 C++ 类构成，同时提供了Python、Ruby、MATLAB等语言的接口，实现了图像处理和计算机视觉方面的很多通用算法。 OpenCV用C++语言编写，它的主要接口也是C++语言，但是依然保留了大量的C语言接口。  \n",
    "　　在计算机视觉项目的开发中，OpenCV作为较大众的开源库，拥有了丰富的常用图像处理函数库，采用C/C++语言编写，可以运行在Linux/Windows/Mac等操作系统上，能够快速的实现一些图像处理和识别的任务。此外，OpenCV还提供了Java、python、cuda等的使用接口、机器学习的基础算法调用，从而使得图像处理和图像分析变得更加易于上手，让开发人员更多的精力花在算法的设计上。\n",
    "### 1.2、应用领域\n",
    "#### 1.2.1、计算机视觉领域方向\n",
    "1、人机互动  \n",
    "2、物体识别  \n",
    "3、图像分割  \n",
    "4、人脸识别  \n",
    "5、动作识别  \n",
    "6、运动跟踪  \n",
    "7、机器人  \n",
    "8、运动分析  \n",
    "9、机器视觉  \n",
    "10、结构分析  \n",
    "11、汽车安全驾驶  \n",
    "#### 1.2.2、计算机操作底层技术\n",
    "图像数据的操作： 分配、释放、复制、设置和转换。 图像是视频的输入输出I/O ，文件与摄像头的输入、图像和视频文件输出）。  \n",
    "矩阵和向量的操作以及线性代数的算法程序：矩阵积、解方程、特征值以及奇异值等。  \n",
    "各种动态数据结构：列表、队列、集合、树、图等。   \n",
    "基本的数字图像处理：滤波、边缘检测、角点检测、采样与差值、色彩转换、形态操作、直方图、图像金字塔等。   \n",
    "结构分析：连接部件、轮廓处理、距离变换、各自距计算、模板匹配、Hough变换、多边形逼近、直线拟合、椭圆拟合、Delaunay 三角划分等。   \n",
    "摄像头定标：发现与跟踪定标模式、定标、基本矩阵估计、齐次矩阵估计、立体对应。  \n",
    "运动分析：光流、运动分割、跟踪。   \n",
    "目标识别：特征法、隐马尔可夫模型：HMM。  \n",
    "基本的GUI：图像与视频显示、键盘和鼠标事件处理、滚动条。   \n",
    "图像标注：线、二次曲线、多边形、画文字。  \n",
    " \n",
    "## 二、安装OpenCV\n",
    "　　安装的时候是 opencv_python，但在导入的时候采用 import cv2。\n",
    "### 2.1、安装方法1：\n",
    "　　使用whl文件法：先去官网 https://www.lfd.uci.edu/~gohlke/pythonlibs/#opencv ，下载相应Python版本的OpenCV的whl文件，如本人下载的opencv_python‑3.4.1‑cp36‑cp36m‑win_amd64.whl，然后在whl文件所在目录下，使用命令进行安装即可。\n",
    ">pip install opencv_python‑3.4.1‑cp36‑cp36m‑win_amd64.whl\n",
    "\n",
    "### 2.2、安装方法2：\n",
    "　　直接命令法  \n",
    ">pip install opencv-python  \n",
    "\n",
    "### 2.3、安装方法3：\n",
    "　　Anaconda 环境下安装\n",
    ">pip/conda install opencv-python    //Anaconda 环境下安装，先打开Anaconda Prompt，再输入本命令进行安装！\n",
    "\n",
    "## 三、OpenCV基本函数、方法\n",
    "　　opencv中opencv不接受non-ascii的路径（不支持中文路径）。\n",
    "### 3.1、imread\n",
    ">cv2.imread(filepath,flags)     #读入一张图像\n",
    "\n",
    "　filepath：要读入图片的完整路径<br>\n",
    "　flags：读入图片的标志 <br>\n",
    "　　cv2.IMREAD_COLOR：默认参数，读入一副彩色图片，忽略alpha通道<br>\n",
    "　　cv2.IMREAD_GRAYSCALE：读入灰度图片<br>\n",
    "　　cv2.IMREAD_UNCHANGED：顾名思义，读入完整图片，包括alpha通道<br>\n",
    "\n",
    "### 3.2、imshow\n",
    ">cv2.imshow(wname,img)     #显示图像<br>\n",
    "\n",
    "　wname: 显示图像的窗口的名字  　\n",
    "　img: 要显示的图像（imread读入的图像），窗口大小自动调整为图片大小　  　\n",
    "\n",
    "```python\n",
    "cv2.imshow('image',img)\n",
    "cv2.waitKey(0)   #等待键盘输入，单位为毫秒，即等待指定的毫秒数看是否有键盘输入，若在等待时间内按下任意键则返回按键的ASCII码，程序继续运行。\n",
    "#若没有按下任何键，超时后返回-1。参数为0表示无限等待。不调用waitKey的话，窗口会一闪而逝，看不到显示的图片。\n",
    "cv2.destroyAllWindow()     #销毁所有窗口\n",
    "cv2.destroyWindow(wname)   #销毁指定窗口\n",
    "```\n",
    "### 3.3、imwrite\n",
    ">cv2.imwrite(file，img，num)    #保存一张图像\n",
    "\n",
    "　file: 保存的文件名  \n",
    "　img: 要保存的图像。可选的第三个参数，它针对特定的格式：对于JPEG，其表示的是图像的质量，用0 - 100的整数表示，默认95。  \n",
    "　num: 压缩级别。默认为3。  \n",
    "\n",
    "### 3.3、copy\n",
    "img.copy()    #图像复制\n",
    "\n",
    "### 3.4、cvtColor \n",
    ">cv2.cvtColor()      #图像颜色空间转换\n",
    "\n",
    "```python\n",
    "img2 = cv2.cvtColor(img,cv2.COLOR_RGB2GRAY)   #灰度化：彩色图像转为灰度图像  \n",
    "img3 = cv2.cvtColor(img,cv2.COLOR_GRAY2RGB)   #彩色化：灰度图像转为彩色图像  \n",
    "#cv2.COLOR_X2Y，其中X,Y = RGB, BGR, GRAY, HSV, YCrCb, XYZ, Lab, Luv, HLS  \n",
    "```\n",
    "### 3.5、resize\n",
    "cv2.resize(image, image2,dsize)     #图像缩放：(输入原始图像，输出新图像，图像的大小)\n",
    "\n",
    "### 3.6、flip\n",
    "cv2.flip(img,flipcode)                       #图像翻转，flipcode控制翻转效果。\n",
    "　flipcode = 0：沿x轴翻转；flipcode > 0：沿y轴翻转；flipcode < 0：x,y轴同时翻转\n",
    "\n",
    "### 3.7、warpAffine\n",
    "cv2.warpAffine(img, M, (400, 600))       #图像仿射变换 ：平移；裁剪、剪切、旋转、仿射变换，\n",
    "M、M_crop、M_shear、M_rotate\n",
    "\n",
    "### 3.8、putText\n",
    "cv2.putText(img,'text',(50,150)   #图像添加文字：(照片，添加的文字，左上角坐标，字体，字体大小，颜色，字体粗细)\n",
    "```py\n",
    "cv2.putText(image, caption, (b[0], b[1] - 10), cv2.FONT_HERSHEY_PLAIN, 1, (255, 0, 0), 1)  \n",
    "cv2.putText(I,'there 0 error(s):',(50,150),cv2.FONT_HERSHEY_COMPLEX,6,(0,0,255),25)  \n",
    "```\n",
    "### 3.9、rectangle\n",
    "cv2.rectangle(img, (x,y), (x+w,y+h), (0,255,0), 2)    #画出矩行：img原图、(x，y)是矩阵的左上点坐标、(x+w，y+h)是矩阵的右下点坐标、(0,255,0)是画线对应的rgb颜色、2是所画的线的宽度。\n",
    "\n",
    "### 3.10、boundingRect\n",
    "cv2.boundingRect(img)          #返回图像的四值属性：img是一个二值图，即是它的参数； 返回四个值，分别是x，y，w，h； x，y是矩阵左上点的坐标，w，h是矩阵的宽和高。\n",
    "![表格图片]()\n",
    "\n",
    "### 3.11、imencode\n",
    "cv2.imencode()函数是将图片格式转换(编码)成流数据，赋值到内存缓存中;主要用于图像数据格式的压缩，方便网络传输。\n",
    "### 3.1２、imdecode\n",
    "cv2.imdecode()函数从指定的内存缓存中读取数据，并把数据转换(解码)成图像格式;主要用于从网络传输数据中恢复出图像。\n",
    "\n",
    "### 3.13、matchTemplate\n",
    ">cv2.matchTemplate(image, templ, method, result=None, mask=None)    # 目标匹配函数\n",
    "\n",
    "　image：待搜索图像  \n",
    "　templ：模板图像  \n",
    "　result：匹配结果  \n",
    "　method：计算匹配程度的方法  \n",
    "　关于参数 method：  \n",
    "　　CV_TM_SQDIFF 平方差匹配法：采用平方差来进行匹配；最好的匹配值为0；匹配越差，匹配值越大。  \n",
    "　　CV_TM_CCORR 相关匹配法：该方法采用乘法操作；数值越大表明匹配程度越好。  \n",
    "　　CV_TM_CCOEFF 相关系数匹配法：1表示完美的匹配；-1表示最差的匹配。  \n",
    "　　CV_TM_SQDIFF_NORMED 归一化平方差匹配法  \n",
    "　　CV_TM_CCORR_NORMED 归一化相关匹配法  \n",
    "　　CV_TM_CCOEFF_NORMED 归一化相关系数匹配法  \n",
    " **匹配方法:** 使用不同的方法产生的结果的意义可能不太一样，有些返回的值越大表示匹配程度越好，而有些方法返回的值越小表示匹配程度越好。 \n",
    "\n",
    "### 3.14、imdecode\n",
    ">cv2.minMaxLoc(src, mask=None)\n",
    "\n",
    "src是一个矩阵。  \n",
    "函数功能：假设有一个矩阵a,现在需要求这个矩阵的最小值，最大值，并得到最大值，最小值的索引。咋一看感觉很复杂，但使用这个cv2.minMaxLoc()函数就可全部解决。函数返回的四个值就是上述所要得到的。  \n",
    "```py\n",
    "import numpy as np\n",
    "import cv2\n",
    "a=np.array([[2,3,4,5],[5,67,8,9],[1,3,4,5]])\n",
    "print(a)\n",
    "min_val,max_val,min_indx,max_indx=cv2.minMaxLoc(a)\n",
    "\n",
    "print(min_val,max_val,min_indx,max_indx)\n",
    "```\n",
    "### 3.15、Canny  边缘检测\n",
    "　　参考：[Canny边缘检测算法原理及其VC实现详解(一)](https://blog.csdn.net/likezhaobin/article/details/6892176)<br>\n",
    "　　　　　[Canny算子边缘检测原理及实现](https://blog.csdn.net/weixin_40647819/article/details/91411424)<br>\n",
    "　　　　　[边缘检测算法](https://blog.csdn.net/xiahn1a/article/details/42141429)<br>\n",
    "　　　　　[OpenCV——Canny边缘检测（cv2.Canny()）](https://blog.csdn.net/m0_51402531/article/details/121066693)<br>\n",
    ">edge = cv2.Canny(image, threshold1, threshold2[, edges[, apertureSize[, L2gradient ]]])\n",
    " \n",
    "参数解释:  \n",
    "　　image: 需要处理的原图像，该图像必须为单通道的灰度图（Canny自能处理灰度图）    \n",
    "　　threshold1：阈值1  \n",
    "　　threshold2：阈值2  \n",
    "　　apertureSize：可选参数，Sobel算子的大小  \n",
    "　　其中，较大的阈值2用于检测图像中明显的边缘，但一般情况下检测的效果不会那么完美，边缘检测出来是断断续续的。所以这时候用较小的第一个阈值用于将这些间断的边缘连接起来。    \n",
    "　　可选参数中apertureSize就是Sobel算子的大小。而L2gradient参数是一个布尔值，如果为真，则使用更精确的L2范数进行计算（即两个方向的倒数的平方和再开放），否则使用L1范数（直接将两个方向导数的绝对值相加）。  \n",
    "　　函数返回的是二值图，包含检测出的边缘  \n",
    "\n",
    "### 3.16、i\n",
    "\n",
    "### 3.16、i\n",
    "\n",
    "### 3.16、i\n",
    "\n",
    "\n",
    "### 3.16、i\n",
    "\n",
    "\n",
    "### 3.16、i\n",
    "\n",
    "\n",
    "### 3.16、i\n",
    "\n",
    "## 四、图像基本运算 \n",
    "   图像的基本运算有很多种，比如两幅图像可以相加、相减、相乘、相除、位运算、平方根、对数、绝对值等；图像也可以放大、缩小、旋转，还可以截取其中的一部分作为ROI（感兴趣区域）进行操作，各个颜色通道还可以分别提取及对各个颜色通道进行各种运算操作。\n",
    "\n",
    "### 4.1、像素处理\n",
    "　　bitwise_and、bitwise_or、bitwise_xor、bitwise_not四个按位操作函数，是将基础数学运算应用于图像像素的处理中。\n",
    "```python\n",
    "bitwise_and、bitwise_or、bitwise_xor、bitwise_not这四个按位操作函数。\n",
    "void bitwise_and(InputArray src1, InputArray src2,OutputArray dst, InputArray mask=noArray());//dst = src1 & src2\n",
    "void bitwise_or(InputArray src1, InputArray src2,OutputArray dst, InputArray mask=noArray());//dst = src1 | src2\n",
    "void bitwise_xor(InputArray src1, InputArray src2,OutputArray dst, InputArray mask=noArray());//dst = src1 ^ src2\n",
    "void bitwise_not(InputArray src, OutputArray dst,InputArray mask=noArray());//dst = ~src\n",
    "```\n",
    "bitwise_and()：是对二进制数据进行“与”操作，即对图像（灰度图像或彩色图像均可）每个像素值进行二进制“与”操作，1&1=1，1&0=0，0&1=0，0&0=0\n",
    "bitwise_or()：是对二进制数据进行“或”操作，即对图像（灰度图像或彩色图像均可）每个像素值进行二进制“或”操作，1|1=1，1|0=0，0|1=0，0|0=0\n",
    "bitwise_xor()：是对二进制数据进行“异或”操作，即对图像（灰度图像或彩色图像均可）每个像素值进行二进制“异或”操作，1^1=0,1^0=1,0^1=1,0^0=0\n",
    "bitwise_not()：是对二进制数据进行“非”操作，即对图像（灰度图像或彩色图像均可）每个像素值进行二进制“非”操作，~1=0，~0=1\n",
    "\n",
    "### 4.2、Image.open 和cv2.imread 的区别及其转换\n",
    "　　Image.open 打开来的图像格式，cv2.imread  读出来是像素格式。\n",
    "\n",
    "```python\n",
    "# 1、PIL.Image转换成OpenCV格式：\n",
    "import cv2\n",
    "from PIL import Image\n",
    "import numpy\n",
    " \n",
    "path = 'F:/File_Python/Resources/face_images/LZT01.jpg'\n",
    "img = Image.open(path).convert(\"RGB\")#.convert(\"RGB\")可不要，默认打开就是RGB\n",
    "img.show()\n",
    "#转opencv\n",
    "#img = cv2.cvtColor(numpy.asarray(image),cv2.COLOR_RGB2BGR)\n",
    "img = cv2.cvtColor(np.array(img),cv2.COLOR_RGB2BGR)\n",
    "cv2.imshow(\"OpenCV\",img)\n",
    "cv2.waitKey()\n",
    " \n",
    "# 2、OpenCV转换成PIL.Image格式\n",
    "import cv2\n",
    "from PIL import Image\n",
    "import numpy\n",
    " \n",
    "img = cv2.imread('F:/File_Python/Resources/face_images/LZT01.jpg') # opencv打开的是BRG\n",
    "cv2.imshow(\"OpenCV\",img)\n",
    "image = Image.fromarray(cv2.cvtColor(img,cv2.COLOR_BGR2RGB))\n",
    "image.show()\n",
    "cv2.waitKey()\n",
    "```\n",
    "\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
